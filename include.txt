#pragma once

#include "vertex.hpp"
#include "primitive_type.hpp"
#include "rect.hpp"
#include "drawable.hpp"

#include <memory>

namespace gfx_core {

class VertexArray : public Drawable {
  public:
    VertexArray();

    explicit VertexArray( PrimitiveType type, std::size_t vertex_count = 0 );

    ~VertexArray();

    std::size_t
    getVertexCount() const;

    Vertex&
    operator[]( std::size_t index );

    const Vertex&
    operator[]( std::size_t index ) const;

    void
    clear();

    void
    resize( std::size_t vertex_count );

    void
    append( const Vertex& vertex );

    void
    setPrimitiveType( PrimitiveType type );

    PrimitiveType
    getPrimitiveType() const;

    FloatRect
    getBounds() const;

  private:
    virtual void
    draw( Window& target, Transform transform ) const override;

  private:
    class Impl;
    std::unique_ptr<Impl> impl_;
};

} // namespace gfx_core
#pragma once

#include "color.hpp"
#include "event.hpp"
#include "transform.hpp"
#include "drawable.hpp"

#include <memory>

namespace gfx_core {

class Window {
  public:
    Window( unsigned int width, unsigned int height, const char* title );
    ~Window();

    void
    close();

    bool
    isOpen() const;

    Vector2u
    getSize() const;

    void
    clear( const Color& color = Color::Black );

    void
    display();

    bool
    pollEvent( Event& event );

    void
    setFramerateLimit( unsigned int limit );

    void
    draw( const Drawable& drawable, Transform transform = Transform::Identity );

    void*
    getImpl() const;

  private:
    class Impl;
    std::unique_ptr<Impl> impl_;
};

} // namespace gfx_core
#pragma once

#include "vector2.hpp"

namespace gfx_core {

class Window;

class Mouse {
  public:
    enum Button {
        Left,
        Right,
        Middle,
        XButton1,
        XButton2,

        ButtonCount
    };

    static bool
    isButtonPressed( Button button );

    static Vector2i
    getPosition();

    static Vector2i
    getPosition( const Window& relative_to );

    static void
    setPosition( const Vector2i& position );

    static void
    setPosition( const Vector2i& position, const Window& relative_to );
};

} // namespace gfx_core
#pragma once

namespace gfx_core {

enum PrimitiveType {
    Points,
    Lines,
    LineStrip,
    Triangles,
    TriangleStrip,
    TriangleFan,
    Quads,

};

} // namespace gfx_core
#pragma once

#include "transform.hpp"

namespace gfx_core {

class Transformable {
  public:
    Transformable();

    void
    setPosition( float x, float y );

    void
    setPosition( const Vector2f& position );

    void
    setRotation( float angle );

    void
    setScale( float factor_x, float factor_y );

    void
    setScale( const Vector2f& factors );

    void
    setOrigin( float x, float y );

    void
    setOrigin( const Vector2f& origin );

    Vector2f
    getPosition() const;

    float
    getRotation() const;

    Vector2f
    getScale() const;

    Vector2f
    getOrigin() const;

    void
    move( float offset_x, float offset_y );

    void
    move( const Vector2f& offset );

    void
    rotate( float angle );

    void
    scale( float factor_x, float factor_y );

    void
    scale( const Vector2f& factor );

    const Transform&
    getTransform() const;

    const Transform&
    getInverseTransform() const;

  private:
    Vector2f          origin_{ 0.0f, 0.0f };
    Vector2f          position_{ 0.0f, 0.0f };
    float             rotation_{ 0.0f };
    Vector2f          scale_{ 1.0f, 1.0f };
    mutable Transform transform_;
    mutable bool      transform_need_update_{ true };
};

} // namespace gfx_core
#pragma once

#include "vector2.hpp"

#include <algorithm>

namespace gfx_core {

template<typename T>
class Rect {
  public:
    Rect() : x( 0 ), y( 0 ), w( 0 ), h( 0 ) {}

    Rect( T x, T y, T w, T h ) : x( x ), y( y ), w( w ), h( h ) {}

    Rect( const Vector2<T>& pos, const Vector2<T>& size )
        : x( pos.x ), y( pos.y ), w( size.x ), h( size.y )
    {
    }

    template<typename U>
    explicit Rect( const Rect<U>& rectangle )
        : x( static_cast<T>( rectangle.x ) ), y( static_cast<T>( rectangle.y ) ),
          w( static_cast<T>( rectangle.w ) ), h( static_cast<T>( rectangle.h ) )
    {
    }

    bool
    contains( T x, T y ) const
    {
        T min_x = std::min( x, static_cast<T>( x + w ) );
        T max_x = std::max( x, static_cast<T>( x + w ) );
        T min_y = std::min( y, static_cast<T>( y + h ) );
        T max_y = std::max( y, static_cast<T>( y + h ) );

        return ( x >= min_x ) && ( x < max_x ) && ( y >= min_y ) && ( y < max_y );
    }

    bool
    contains( const Vector2<T>& point ) const
    {
        return contains( point.x, point.y );
    }

    bool
    intersects( const Rect<T>& rectangle ) const
    {
        Rect<T> intersection;
        return intersects( rectangle, intersection );
    }

    bool
    intersects( const Rect<T>& rectangle, Rect<T>& intersection ) const
    {
        T r1_min_x = std::min( x, static_cast<T>( x + w ) );
        T r1_max_x = std::max( x, static_cast<T>( x + w ) );
        T r1_min_y = std::min( y, static_cast<T>( y + h ) );
        T r1_max_y = std::max( y, static_cast<T>( y + h ) );

        T r2_min_x = std::min( rectangle.x, static_cast<T>( rectangle.x + rectangle.w ) );
        T r2_max_x = std::max( rectangle.x, static_cast<T>( rectangle.x + rectangle.w ) );
        T r2_min_y = std::min( rectangle.y, static_cast<T>( rectangle.y + rectangle.h ) );
        T r2_max_y = std::max( rectangle.y, static_cast<T>( rectangle.y + rectangle.h ) );

        T inter_left   = std::max( r1_min_x, r2_min_x );
        T inter_top    = std::max( r1_min_y, r2_min_y );
        T inter_right  = std::min( r1_max_x, r2_max_x );
        T inter_bottom = std::min( r1_max_y, r2_max_y );

        if ( ( inter_left < inter_right ) && ( inter_top < inter_bottom ) )
        {
            intersection = Rect<T>( inter_left,
                                    inter_top,
                                    inter_right - inter_left,
                                    inter_bottom - inter_top );
            return true;
        }

        intersection = Rect<T>( 0, 0, 0, 0 );
        return false;
    }

    Vector2<T>
    getPosition() const
    {
        return Vector2<T>( x, y );
    }

    Vector2<T>
    getSize() const
    {
        return Vector2<T>( w, h );
    }

    T x;
    T y;
    T w;
    T h;
};

template<typename T>
bool
operator==( const Rect<T>& left, const Rect<T>& right )
{
    {
        return ( left.x == right.x ) && ( left.w == right.w ) && ( left.y == right.y ) &&
               ( left.h == right.h );
    }
}

template<typename T>
bool
operator!=( const Rect<T>& left, const Rect<T>& right )
{
    return !( left == right );
}

typedef Rect<int>   IntRect;
typedef Rect<float> FloatRect;

} // namespace gfx_core
#pragma once

#include "color.hpp"
#include "vector2.hpp"

namespace gfx_core {

class Vertex {
  public:
    Vertex( const Vector2f& the_position );

    Vertex( const Vector2f& the_position, const Color& the_color );

    Vertex( const Vector2f& the_position, const Vector2f& the_tex_coords );

    Vertex( const Vector2f& the_position, const Color& the_color, const Vector2f& the_tex_coords );

    Vector2f position;
    Color    color;
    Vector2f tex_coords;
};

} // namespace gfx_core
#pragma once

#include "color.hpp"
#include "drawable.hpp"
#include "transformable.hpp"
#include "vector2.hpp"

#include <memory>

namespace gfx_core {

class CircleShape : public Drawable, public Transformable {
  public:
    explicit CircleShape( float radius = 0.0f );
    ~CircleShape();

    void
    setRadius( float radius );

    float
    getRadius() const;

    void
    setFillColor( const gfx_core::Color& color );

    virtual void
    draw( Window& window, Transform transform ) const override;

  private:
    class Impl;
    std::unique_ptr<Impl> impl_;
};

} // namespace gfx_core
#pragma once

#include "vector2.hpp"

#include <memory>

namespace gfx_core {

class Transform {
  public:
    Transform();
    ~Transform();

    // clang-format off
	Transform(float a00, float a01, float a02,
	          float a10, float a11, float a12,
	          float a20, float a21, float a22);
    // clang-format on

    Transform( const Transform& other );

    Transform&
    operator=( const Transform& other );

    Transform&
    translate( float x, float y );
    Transform&
    translate( const Vector2f& v );

    Transform&
    rotate( float angle_degrees );
    Transform&
    rotate( float angle_degrees, float center_x, float center_y );
    Transform&
    rotate( float angle_degrees, const Vector2f& center );

    Transform&
    scale( float factor );
    Transform&
    scale( const Vector2f& factors );
    Transform&
    scale( float factor, const Vector2f& center );
    Transform&
    scale( const Vector2f& factors, const Vector2f& center );

    Transform
    combine( const Transform& other ) const;

    static const Transform Identity;

    void*
    getImpl();

  private:
    struct Impl;
    std::unique_ptr<Impl> impl_;
};

} // namespace gfx_core
#pragma once

namespace gfx_core {

template<typename T>
class Vector2 {
  public:
    T x{};
    T y{};

    constexpr Vector2() : x( 0 ), y( 0 ) {}

    constexpr Vector2( T X, T Y ) : x( X ), y( Y ) {}

    template<typename U>
    constexpr Vector2( const Vector2<U>& vector )
        : x( static_cast<T>( vector.x ) ), y( static_cast<T>( vector.y ) )
    {
    }

    constexpr friend Vector2<T>
    operator-( const Vector2<T>& right )
    {
        return Vector2<T>( -right.x, -right.y );
    }

    constexpr friend Vector2<T>&
    operator+=( Vector2<T>& left, const Vector2<T>& right )
    {
        left.x += right.x;
        left.y += right.y;

        return left;
    }

    constexpr friend Vector2<T>&
    operator-=( Vector2<T>& left, const Vector2<T>& right )
    {
        left.x -= right.x;
        left.y -= right.y;

        return left;
    }

    constexpr friend Vector2<T>
    operator+( const Vector2<T>& left, const Vector2<T>& right )
    {
        return Vector2<T>( left.x + right.x, left.y + right.y );
    }

    constexpr friend Vector2<T>
    operator-( const Vector2<T>& left, const Vector2<T>& right )
    {
        return Vector2<T>( left.x - right.x, left.y - right.y );
    }

    constexpr friend Vector2<T>
    operator*( const Vector2<T>& left, T right )
    {
        return Vector2<T>( left.x * right, left.y * right );
    }

    constexpr friend Vector2<T>
    operator*( T left, const Vector2<T>& right )
    {
        return Vector2<T>( right.x * left, right.y * left );
    }

    constexpr friend Vector2<T>&
    operator*=( Vector2<T>& left, T right )
    {
        left.x *= right;
        left.y *= right;

        return left;
    }

    constexpr friend Vector2<T>
    operator/( const Vector2<T>& left, T right )
    {
        return Vector2<T>( left.x / right, left.y / right );
    }

    constexpr friend Vector2<T>&
    operator/=( Vector2<T>& left, T right )
    {
        left.x /= right;
        left.y /= right;

        return left;
    }

    constexpr friend bool
    operator==( const Vector2<T>& left, const Vector2<T>& right )
    {
        return ( left.x == right.x ) && ( left.y == right.y );
    }

    constexpr friend bool
    operator!=( const Vector2<T>& left, const Vector2<T>& right )
    {
        return ( left.x != right.x ) || ( left.y != right.y );
    }
};

using Vector2f = Vector2<float>;
using Vector2i = Vector2<int>;
using Vector2u = Vector2<unsigned int>;

} // namespace gfx_core
#pragma once

#include "transform.hpp"

namespace gfx_core {

class Window;

class Drawable {
  public:
    virtual ~Drawable() = default;

    virtual void
    draw( Window& target, Transform transform ) const = 0;
};

} // namespace gfx_core
#pragma once

#include "color.hpp"
#include "drawable.hpp"
#include "transform.hpp"
#include "transformable.hpp"
#include "vector2.hpp"

#include <memory>

namespace gfx_core {

class RectangleShape : public Drawable, public Transformable {
  public:
    RectangleShape( const Vector2f& size = Vector2f( 0, 0 ) );
    ~RectangleShape();

    void
    setSize( const Vector2f& size );

    Vector2f
    getSize() const;

    void
    setFillColor( const gfx_core::Color& color );

    virtual void
    draw( Window& window, Transform transform ) const override;

  private:
    class Impl;
    std::unique_ptr<Impl> impl_;
};

} // namespace gfx_core
#pragma once

#include "mouse.hpp"

namespace gfx_core {

class Event {
  public:
    struct MouseMoveEvent
    {
        int x;
        int y;
    };

    struct MouseButtonEvent
    {
        Mouse::Button button;
        int           x;
        int           y;
    };

    enum Type { Closed, MouseButtonPressed, MouseButtonReleased, MouseMoved, Unknown };

    Type type;

    union {
        MouseMoveEvent   mouse_move;
        MouseButtonEvent mouse_button;
    };

    Event() : type( Unknown ) {}
};

} // namespace gfx_core
#pragma once

namespace gfx_core {

class Color {
  public:
    unsigned char r, g, b, a;

    constexpr Color() : r( 0 ), g( 0 ), b( 0 ), a( 255 ) {}

    constexpr Color( unsigned char r, unsigned char g, unsigned char b, unsigned char a = 255 )
        : r( r ), g( g ), b( b ), a( a )
    {
    }

    static const Color White;
    static const Color Black;
    static const Color Red;
    static const Color Green;
    static const Color Blue;
};

inline constexpr Color Color::White{ 255, 255, 255 };
inline constexpr Color Color::Black{ 0, 0, 0 };
inline constexpr Color Color::Red{ 255, 0, 0 };
inline constexpr Color Color::Green{ 0, 255, 0 };
inline constexpr Color Color::Blue{ 0, 0, 255 };

} // namespace gfx_core

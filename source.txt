#include "vertex.hpp"
#include "color.hpp"
#include "vector2.hpp"

namespace gfx_core {

Vertex::Vertex( const Vector2f& the_position )
{
    position   = the_position;
    color      = Color::White;
    tex_coords = Vector2f( 0, 0 );
}

Vertex::Vertex( const Vector2f& the_position, const Color& the_color )
{
    position   = the_position;
    color      = the_color;
    tex_coords = Vector2f( 0, 0 );
}

Vertex::Vertex( const Vector2f& the_position, const Vector2f& the_tex_coords )
{
    position   = the_position;
    color      = Color::White;
    tex_coords = the_tex_coords;
}

Vertex::Vertex( const Vector2f& the_position,
                const Color&    the_color,
                const Vector2f& the_tex_coords )
{
    position   = the_position;
    color      = the_color;
    tex_coords = the_tex_coords;
}

} // namespace gfx_core
#include "circle_shape.hpp"
#include "transform.hpp"
#include "window.hpp"

#include <SFML/Graphics/CircleShape.hpp>
#include <SFML/Graphics/Color.hpp>
#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/Graphics/Transform.hpp>

namespace gfx_core {

class CircleShape::Impl {
  public:
    sf::CircleShape circle_shape;

    explicit Impl( float radius ) : circle_shape( radius ) { circle_shape.setScale( { 1, 1 } ); }

    Impl() = default;
};

CircleShape::~CircleShape() = default;

CircleShape::CircleShape( float radius ) : impl_( std::make_unique<Impl>( radius ) ) {}

void
CircleShape::setRadius( float radius )
{
    impl_->circle_shape.setRadius( radius );
}

float
CircleShape::getRadius() const
{
    return impl_->circle_shape.getRadius();
}

void
CircleShape::setFillColor( const gfx_core::Color& color )
{
    sf::Color sf_color( color.r, color.g, color.b, color.a );

    impl_->circle_shape.setFillColor( sf_color );
}

void
CircleShape::draw( Window& window, Transform transform ) const
{
    Transform local_transform = transform.combine( getTransform() );

    auto* sf_window    = static_cast<sf::RenderWindow*>( window.getImpl() );
    auto* sf_transform = static_cast<sf::Transform*>( local_transform.getImpl() );

    sf_window->draw( impl_->circle_shape, *sf_transform );
}

} // namespace gfx_core
#include "vertex_array.hpp"
#include "window.hpp"
#include "primitive_type.hpp"
#include "vertex.hpp"

#include <SFML/Graphics/VertexArray.hpp>
#include <SFML/Graphics/Vertex.hpp>
#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/Graphics/PrimitiveType.hpp>
#include <SFML/System/Vector2.hpp>

static_assert( sizeof( gfx_core::Vertex ) == sizeof( sf::Vertex ) );
static_assert( offsetof( gfx_core::Vertex, position ) == offsetof( sf::Vertex, position ) );
static_assert( offsetof( gfx_core::Vertex, color ) == offsetof( sf::Vertex, color ) );
static_assert( offsetof( gfx_core::Vertex, tex_coords ) == offsetof( sf::Vertex, texCoords ) );

namespace gfx_core {

namespace detail {

extern sf::PrimitiveType
toSFML( PrimitiveType type );

extern PrimitiveType
fromSFML( sf::PrimitiveType type );

} // namespace detail

class VertexArray::Impl {
  public:
    sf::VertexArray vertices;

    Impl() = default;
    Impl( PrimitiveType type, std::size_t vertex_count )
        : vertices( detail::toSFML( type ), vertex_count )
    {
    }
};

VertexArray::VertexArray() : impl_( std::make_unique<Impl>() ) {}

VertexArray::~VertexArray() = default;

VertexArray::VertexArray( PrimitiveType type, std::size_t vertex_count )
    : impl_( std::make_unique<Impl>( type, vertex_count ) )
{
}

std::size_t
VertexArray::getVertexCount() const
{
    return impl_->vertices.getVertexCount();
}

Vertex&
VertexArray::operator[]( std::size_t index )
{
    return *reinterpret_cast<Vertex*>( &impl_->vertices[index] );
}

const Vertex&
VertexArray::operator[]( std::size_t index ) const
{
    return *reinterpret_cast<const Vertex*>( &impl_->vertices[index] );
}

void
VertexArray::clear()
{
    impl_->vertices.clear();
}

void
VertexArray::resize( std::size_t vertex_count )
{
    impl_->vertices.resize( vertex_count );
}

void
VertexArray::append( const Vertex& vertex )
{
    impl_->vertices.append( *reinterpret_cast<const sf::Vertex*>( &vertex ) );
}

void
VertexArray::setPrimitiveType( PrimitiveType type )
{
    impl_->vertices.setPrimitiveType( detail::toSFML( type ) );
}

PrimitiveType
VertexArray::getPrimitiveType() const
{
    return detail::fromSFML( impl_->vertices.getPrimitiveType() );
}

FloatRect
VertexArray::getBounds() const
{
    sf::FloatRect sf_bounds = impl_->vertices.getBounds();
    return FloatRect{ sf_bounds.left, sf_bounds.top, sf_bounds.width, sf_bounds.height };
}

void
VertexArray::draw( Window& target, Transform transform ) const
{
    auto* sf_window    = static_cast<sf::RenderWindow*>( target.getImpl() );
    auto* sf_transform = static_cast<sf::Transform*>( transform.getImpl() );

    sf_window->draw( impl_->vertices );
}

} // namespace gfx_core
#include "transformable.hpp"
#include "transform.hpp"
#include "vector2.hpp"

#include <cmath>

namespace gfx_core {

Transformable::Transformable() = default;

void
Transformable::setPosition( float x, float y )
{
    position_              = Vector2f( x, y );
    transform_need_update_ = true;
}

void
Transformable::setPosition( const Vector2f& position )
{
    position_              = position;
    transform_need_update_ = true;
}

void
Transformable::setRotation( float angle )
{
    rotation_              = angle;
    transform_need_update_ = true;
}

void
Transformable::setScale( float x, float y )
{
    scale_                 = Vector2f( x, y );
    transform_need_update_ = true;
}

void
Transformable::setScale( const Vector2f& factors )
{
    scale_                 = factors;
    transform_need_update_ = true;
}

void
Transformable::setOrigin( float x, float y )
{
    origin_                = Vector2f( x, y );
    transform_need_update_ = true;
}

void
Transformable::setOrigin( const Vector2f& origin )
{
    origin_                = origin;
    transform_need_update_ = true;
}

Vector2f
Transformable::getPosition() const
{
    return position_;
}

float
Transformable::getRotation() const
{
    return rotation_;
}

Vector2f
Transformable::getScale() const
{
    return scale_;
}

Vector2f
Transformable::getOrigin() const
{
    return origin_;
}

void
Transformable::move( float offset_x, float offset_y )
{
    setPosition( position_ + Vector2f( offset_x, offset_y ) );
}

void
Transformable::move( const Vector2f& offset )
{
    setPosition( position_ + offset );
}

void
Transformable::rotate( float angle )
{
    setRotation( rotation_ + angle );
}

void
Transformable::scale( float factor_x, float factor_y )
{
    setScale( { scale_.x * factor_x, scale_.y * factor_y } );
}

void
Transformable::scale( const Vector2f& factor )
{
    setScale( { scale_.x * factor.x, scale_.y * factor.y } );
}

const Transform&
Transformable::getTransform() const
{
    if ( transform_need_update_ )
    {
        const float angle  = ( -rotation_ / 180.0f ) * M_PI;
        const float cosine = std::cos( angle );
        const float sine   = std::sin( angle );
        const float sxc    = scale_.x * cosine;
        const float syc    = scale_.y * cosine;
        const float sxs    = scale_.x * sine;
        const float sys    = scale_.y * sine;
        const float tx     = -origin_.x * sxc - origin_.y * sys + position_.x;
        const float ty     = origin_.x * sxs - origin_.y * syc + position_.y;

        // clang-format off
        transform_ = Transform( sxc, sys, tx,
                                -sxs, syc, ty,
                                0.f, 0.f, 1.f);
        // clang-format on

        transform_need_update_ = false;
    }

    return transform_;
}

} // namespace gfx_core
#include "primitive_type.hpp"

#include <SFML/Graphics/PrimitiveType.hpp>

namespace gfx_core {
namespace detail {

sf::PrimitiveType
toSFML( PrimitiveType type )
{
    switch ( type )
    {
        case PrimitiveType::Points:
            return sf::Points;
        case PrimitiveType::Lines:
            return sf::Lines;
        case PrimitiveType::LineStrip:
            return sf::LineStrip;
        case PrimitiveType::Triangles:
            return sf::Triangles;
        case PrimitiveType::TriangleStrip:
            return sf::TriangleStrip;
        case PrimitiveType::TriangleFan:
            return sf::TriangleFan;
        default:
            return sf::Triangles;
    }
}

PrimitiveType
fromSFML( sf::PrimitiveType type )
{
    switch ( type )
    {
        case sf::Points:
            return PrimitiveType::Points;
        case sf::Lines:
            return PrimitiveType::Lines;
        case sf::LineStrip:
            return PrimitiveType::LineStrip;
        case sf::Triangles:
            return PrimitiveType::Triangles;
        case sf::TriangleStrip:
            return PrimitiveType::TriangleStrip;
        case sf::TriangleFan:
            return PrimitiveType::TriangleFan;
        default:
            return PrimitiveType::Triangles;
    }
}

} // namespace detail
} // namespace gfx_core
#include "transform.hpp"

#include <SFML/Graphics/Transform.hpp>
#include <cstdio>
#include <memory>

namespace gfx_core {

class Transform::Impl {
  public:
    sf::Transform transform;
};

void*
Transform::getImpl()
{
    return &impl_->transform;
}

Transform::~Transform() = default;

const Transform Transform::Identity = Transform();

Transform::Transform() : impl_( std::make_unique<Impl>() ) {}

// clang-format off
Transform::Transform(float a00, float a01, float a02,
                     float a10, float a11, float a12,
                     float a20, float a21, float a22)
    : impl_(std::make_unique<Impl>())
{
    impl_->transform = sf::Transform(
        a00, a01, a02,
        a10, a11, a12,
        a20, a21, a22
    );
}
// clang-format on

Transform::Transform( const Transform& other ) : impl_( std::make_unique<Impl>( *other.impl_ ) ) {}

Transform&
Transform::operator=( const Transform& other )
{
    if ( this != &other )
    {
        impl_ = std::make_unique<Impl>( *other.impl_ );
    }

    return *this;
}

Transform&
Transform::translate( float x, float y )
{
    impl_->transform.translate( x, y );
    return *this;
}

Transform&
Transform::translate( const Vector2f& v )
{
    return translate( v.x, v.y );
}

Transform&
Transform::rotate( float angle_degrees )
{
    impl_->transform.rotate( angle_degrees );

    return *this;
}

Transform&
Transform::rotate( float angle_degrees, float center_x, float center_y )
{
    impl_->transform.rotate( angle_degrees, center_x, center_y );

    return *this;
}

Transform&
Transform::rotate( float angle_degrees, const Vector2f& center )
{
    impl_->transform.rotate( angle_degrees, center.x, center.y );

    return *this;
}

Transform&
Transform::scale( float factor )
{
    impl_->transform.scale( factor, factor );
    return *this;
}

Transform&
Transform::scale( const Vector2f& factors )
{
    impl_->transform.scale( factors.x, factors.y );
    return *this;
}

Transform&
Transform::scale( float factor, const Vector2f& center )
{
    impl_->transform.scale( factor, factor, center.x, center.y );
    return *this;
}

Transform&
Transform::scale( const Vector2f& factors, const Vector2f& center )
{
    impl_->transform.scale( factors.x, factors.y, center.x, center.y );
    return *this;
}

Transform
Transform::combine( const Transform& other ) const
{
    Transform result;
    result.impl_->transform = impl_->transform * other.impl_->transform;

    return result;
}

} // namespace gfx_core
#include "mouse.hpp"
#include "window.hpp"

#include <SFML/Window/Mouse.hpp>
#include <SFML/Graphics/RenderWindow.hpp>

namespace gfx_core {

namespace detail {

sf::Mouse::Button
toSFML( Mouse::Button button )
{
    switch ( button )
    {
        case Mouse::Left:
            return sf::Mouse::Left;
        case Mouse::Right:
            return sf::Mouse::Right;
        case Mouse::Middle:
            return sf::Mouse::Middle;
        case Mouse::XButton1:
            return sf::Mouse::XButton1;
        case Mouse::XButton2:
            return sf::Mouse::XButton2;
        default:
            return sf::Mouse::ButtonCount;
    }
}

Mouse::Button
fromSFML( sf::Mouse::Button button )
{
    switch ( button )
    {
        case sf::Mouse::Left:
            return Mouse::Left;
        case sf::Mouse::Right:
            return Mouse::Right;
        case sf::Mouse::Middle:
            return Mouse::Middle;
        case sf::Mouse::XButton1:
            return Mouse::XButton1;
        case sf::Mouse::XButton2:
            return Mouse::XButton2;
        default:
            return Mouse::ButtonCount;
    }
}

} // namespace detail

Vector2i
Mouse::getPosition()
{
    auto pos = sf::Mouse::getPosition();
    return Vector2i( pos.x, pos.y );
}

Vector2i
Mouse::getPosition( const Window& relative_to )
{
    const auto* sf_window = static_cast<const sf::RenderWindow*>( relative_to.getImpl() );

    if ( sf_window == nullptr )
    {
        return Vector2i( 0, 0 );
    }

    auto pos = sf::Mouse::getPosition( *sf_window );
    return Vector2i( pos.x, pos.y );
}

void
Mouse::setPosition( const Vector2i& position )
{
    sf::Mouse::setPosition( sf::Vector2i( position.x, position.y ) );
}

void
Mouse::setPosition( const Vector2i& position, const Window& relative_to )
{
    const auto* sf_window = static_cast<const sf::RenderWindow*>( relative_to.getImpl() );

    if ( sf_window != nullptr )
    {
        sf::Mouse::setPosition( sf::Vector2i( position.x, position.y ), *sf_window );
    }
}

bool
Mouse::isButtonPressed( Button button )
{
    return sf::Mouse::isButtonPressed( detail::toSFML( button ) );
}

} // namespace gfx_core
#include "rectangle_shape.hpp"
#include "transform.hpp"
#include "vector2.hpp"
#include "window.hpp"

#include <SFML/Graphics/RectangleShape.hpp>
#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/System/Vector2.hpp>

namespace gfx_core {

class RectangleShape::Impl {
  public:
    sf::RectangleShape rectangle_shape;

    explicit Impl( const Vector2f& size = Vector2f( 0, 0 ) )
    {
        sf::Vector2f sf_vector( size.x, size.y );
        rectangle_shape.setSize( sf_vector );
    }

    Impl() = default;
};

RectangleShape::~RectangleShape() = default;

RectangleShape::RectangleShape( const Vector2f& size ) : impl_( std::make_unique<Impl>( size ) ) {}

void
RectangleShape::setSize( const Vector2f& size )
{
    sf::Vector2f sf_vector( size.x, size.y );
    impl_->rectangle_shape.setSize( sf_vector );
}

Vector2f
RectangleShape::getSize() const
{
    auto sf_size = impl_->rectangle_shape.getSize();

    return Vector2f( sf_size.x, sf_size.y );
}

void
RectangleShape::setFillColor( const Color& color )
{
    sf::Color sf_color( color.r, color.g, color.b, color.a );

    impl_->rectangle_shape.setFillColor( sf_color );
}

void
RectangleShape::draw( Window& window, Transform transform ) const
{
    Transform local_transform = transform.combine( getTransform() );

    auto* sf_window    = static_cast<sf::RenderWindow*>( window.getImpl() );
    auto* sf_transform = static_cast<sf::Transform*>( local_transform.getImpl() );

    sf_window->draw( impl_->rectangle_shape, *sf_transform );
}

} // namespace gfx_core
#include "drawable.hpp"
#include "transform.hpp"
#include "vector2.hpp"
#include "window.hpp"

#include <SFML/Graphics/CircleShape.hpp>
#include <SFML/Graphics/Color.hpp>
#include <SFML/Graphics/Drawable.hpp>
#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/Graphics/Shape.hpp>
#include <SFML/Graphics/Sprite.hpp>
#include <SFML/System/Vector2.hpp>
#include <SFML/Window/Event.hpp>

namespace gfx_core {

namespace detail {

extern Mouse::Button
fromSFML( sf::Mouse::Button button );

}

class Window::Impl {
  public:
    sf::RenderWindow window;

    Impl( unsigned int width, unsigned int height, const char* title )
        : window( sf::VideoMode( width, height ), title )
    {
    }

    Impl() = default;
};

void*
Window::getImpl() const
{
    return &impl_->window;
}

Window::Window( unsigned int width, unsigned int height, const char* title )
    : impl_( std::make_unique<Impl>( width, height, title ) )
{
}

Window::~Window() = default;

void
Window::close()
{
    impl_->window.close();
}

bool
Window::isOpen() const
{
    return impl_->window.isOpen();
}

Vector2u
Window::getSize() const
{
    sf::Vector2u sf_vector = impl_->window.getSize();
    return Vector2u( sf_vector.x, sf_vector.y );
}

void
Window::clear( const Color& color )
{
    sf::Color sf_color( color.r, color.g, color.b, color.a );
    impl_->window.clear( sf_color );
}

void
Window::display()
{
    impl_->window.display();
}

void
Window::setFramerateLimit( unsigned int limit )
{
    impl_->window.setFramerateLimit( limit );
}

void
Window::draw( const Drawable& drawable, Transform transform )
{
    drawable.draw( *this, transform );
}

bool
Window::pollEvent( Event& event )
{
    sf::Event sf_event;

    if ( impl_->window.pollEvent( sf_event ) )
    {
        switch ( sf_event.type )
        {
            case sf::Event::Closed:
                event.type = Event::Closed;
                break;
            case sf::Event::MouseButtonPressed:
                event.type                = Event::MouseButtonPressed;
                event.mouse_button.button = detail::fromSFML( sf_event.mouseButton.button );
                event.mouse_button.x      = sf_event.mouseButton.x;
                event.mouse_button.y      = sf_event.mouseButton.y;
                break;
            case sf::Event::MouseButtonReleased:
                event.type                = Event::MouseButtonReleased;
                event.mouse_button.button = detail::fromSFML( sf_event.mouseButton.button );
                event.mouse_button.x      = sf_event.mouseButton.x;
                event.mouse_button.y      = sf_event.mouseButton.y;
                break;
            case sf::Event::MouseMoved:
                event.type         = Event::MouseMoved;
                event.mouse_move.x = sf_event.mouseMove.x;
                event.mouse_move.y = sf_event.mouseMove.y;
                break;
            default:
                event.type = Event::Unknown;
                break;
        }

        return true;
    }

    return false;
}

} // namespace gfx_core
#include "color.hpp"
#include "drawable.hpp"
#include "event.hpp"
#include "mouse.hpp"
#include "primitive_type.hpp"
#include "rectangle_shape.hpp"
#include "transform.hpp"
#include "vector2.hpp"
#include "vertex_array.hpp"
#include "window.hpp"
#include "circle_shape.hpp"
#include <memory>
#include <vector>

class Circles : public gfx_core::Drawable {
  public:
    void
    AddCircle( float x, float y )
    {
        auto p = std::make_unique<gfx_core::CircleShape>( 10.0f );
        p->setFillColor( gfx_core::Color::Green );
        p->setPosition( x, y );

        circles_.push_back( std::move( p ) );
    }

  private:
    virtual void
    draw( gfx_core::Window& window, gfx_core::Transform transform ) const override
    {
        for ( const auto& circle : circles_ )
        {
            window.draw( *circle );
        }
    }

  private:
    std::vector<std::unique_ptr<gfx_core::CircleShape>> circles_;
};

class RotatingRects : public gfx_core::Drawable {
  public:
    void
    AddRect( float x, float y )
    {
        auto p = std::make_unique<gfx_core::RectangleShape>( gfx_core::Vector2f( 20.0f, 20.0f ) );
        p->setFillColor( gfx_core::Color::Green );
        p->setPosition( x, y );
        p->setOrigin( 10, 10 );

        rects_.push_back( std::move( p ) );
    }

  private:
    virtual void
    draw( gfx_core::Window& window, gfx_core::Transform transform ) const override
    {
        for ( const auto& rect : rects_ )
        {
            rect->setRotation( angle );
            window.draw( *rect );
        }
    }

  public:
    float angle;

  private:
    std::vector<std::unique_ptr<gfx_core::RectangleShape>> rects_;
};

int
main()
{
    gfx_core::Window window( 800, 600, "My Wrapper" );

    Circles circles;
    circles.AddCircle( 100, 100 );
    circles.AddCircle( 100, 200 );
    circles.AddCircle( 100, 300 );

    RotatingRects rects;
    rects.AddRect( 200, 100 );
    rects.AddRect( 200, 200 );
    rects.AddRect( 200, 300 );

    gfx_core::VertexArray vertex_array( gfx_core::PrimitiveType::TriangleStrip );

    vertex_array.append( gfx_core::Vertex( { 300, 100 }, gfx_core::Color::Red ) );
    vertex_array.append( gfx_core::Vertex( { 370, 130 }, gfx_core::Color::Red ) );
    vertex_array.append( gfx_core::Vertex( { 400, 100 }, gfx_core::Color::Red ) );
    vertex_array.append( gfx_core::Vertex( { 400, 200 }, gfx_core::Color::Red ) );

    bool pressed = false;

    window.setFramerateLimit( 60 );

    while ( window.isOpen() )
    {
        gfx_core::Event event;
        while ( window.pollEvent( event ) )
        {
            switch ( event.type )
            {
                case gfx_core::Event::Closed:
                    window.close();
                    break;
                case gfx_core::Event::MouseButtonPressed:
                    pressed = true;
                    break;
                case gfx_core::Event::MouseButtonReleased:
                    pressed = false;
                    break;
                default:
                    break;
            }
        }

        rects.angle += 1.0f;

        if ( pressed )
        {
            vertex_array[1].position = gfx_core::Mouse::getPosition( window );
        }

        window.clear( gfx_core::Color::Blue );
        window.draw( circles );
        window.draw( rects );
        window.draw( vertex_array );
        window.display();
    }

    return 0;
}
